<div id="je-loading">Loadingâ€¦</div>
<div data-role="content">
  <div class="content-primary je-downloads-page">
    <div id="je-downloads-container"></div>
  </div>
</div>
<div id="je-error" style="display:none">
  Jellyfin Enhanced not ready.
</div>
<script>
(function () {
  const MAX_WAIT = 5000;
  const INTERVAL = 50;
  let waited = 0;

  const loadingEl = document.getElementById("je-loading");
  const errorEl = document.getElementById("je-error");
  const preferencesPages = Array.from(document.querySelectorAll("#userPluginPreferencesPage"));
  const preferencesPage = preferencesPages.find(p => p.offsetWidth > 0 && p.offsetHeight > 0);

  document.querySelectorAll("#je-downloads-container").forEach(el => {
    if (!preferencesPage || !preferencesPage.contains(el)) {
      el.remove();
    }
  });

  if (preferencesPage && !preferencesPage.querySelector("#je-downloads-container")) {
    const newContainer = document.createElement("div");
    newContainer.id = "je-downloads-container";
    const target = document.querySelector(".je-downloads-page") || document.body;
    target.appendChild(newContainer);
  }

  const JE = window.JellyfinEnhanced;

  const timer = setInterval(() => {

    if (JE && JE.downloadsPage) {
      clearInterval(timer);

      loadingEl.remove();
      JE.downloadsPage.injectStyles();
      JE.downloadsPage.renderPage();
      JE.downloadsPage.refresh();
      handleClickOnPlay();
      console.log('ðŸª¼ Jellyfin Enhanced: Downloads Page Loaded.');

      // Use the main module's startPolling which properly respects config and visibility
      // Mark the page as visible for the polling logic
      JE.downloadsPage._pluginPageVisible = true;

      // Start polling - will use the interval from pluginConfig or default to 30 seconds
      if (typeof JE.downloadsPage.startPolling === 'function') {
        JE.downloadsPage.startPolling();
      } else {
        // Fallback: implement auto-refresh for this page
        startPollingFallback();
      }
      return;
    }

    waited += INTERVAL;
    if (waited >= MAX_WAIT) {
      clearInterval(timer);

      loadingEl.style.display = "none";
      errorEl.style.display = "block";
    }
  }, INTERVAL);
})();

function startPollingFallback() {
  const JE = window.JellyfinEnhanced;
  if (!JE || !JE.downloadsPage || typeof JE.downloadsPage.refresh !== "function") return;

  // Check if polling is enabled
  if (!JE.pluginConfig?.DownloadsPagePollingEnabled) {
    return;
  }

  const pollIntervalSeconds = JE.pluginConfig?.DownloadsPollIntervalSeconds !== undefined
    ? JE.pluginConfig.DownloadsPollIntervalSeconds
    : 30;

  if (JE.downloadsPage._pluginPagePollTimer) {
    clearInterval(JE.downloadsPage._pluginPagePollTimer);
  }

  const POLL_INTERVAL = pollIntervalSeconds * 1000;
  JE.downloadsPage._pluginPagePollTimer = setInterval(() => {
    const container = document.getElementById("je-downloads-container");
    // Check visibility: container visible and plugin page is active
    if (container && container.offsetHeight > 0 && container.offsetWidth > 0 && JE.downloadsPage._pluginPageVisible) {
      JE.downloadsPage.refresh();
    }
  }, POLL_INTERVAL);
}

// Clean up polling when page is hidden or document is unloaded
window.addEventListener('beforeunload', () => {
  const JE = window.JellyfinEnhanced;
  if (JE?.downloadsPage?._pluginPagePollTimer) {
    clearInterval(JE.downloadsPage._pluginPagePollTimer);
  }
  JE.downloadsPage._pluginPageVisible = false;
});

function handleClickOnPlay() {
  if (handleClickOnPlay._initialized) return;
  handleClickOnPlay._initialized = true;

  document.addEventListener("click", (e) => {
    const playBtn = e.target.closest(".je-request-watch-btn");
    if (!playBtn) return;

    e.preventDefault();

    const mediaId = playBtn.getAttribute("data-media-id");
    if (mediaId && window.Emby?.Page?.showItem) {
      window.Emby.Page.showItem(mediaId);
    }
  });
}
</script>

